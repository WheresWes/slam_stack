/**
 * @file ply_export.hpp
 * @brief PLY point cloud export with intensity support
 *
 * Supports both ASCII and binary PLY formats.
 * Includes intensity as a scalar property for visualization in
 * CloudCompare, MeshLab, and other tools.
 */

#ifndef SLAM_PLY_EXPORT_HPP
#define SLAM_PLY_EXPORT_HPP

#include <fstream>
#include <string>
#include <vector>
#include <cstdint>
#include <iostream>
#include <iomanip>

#include "slam/types.hpp"

namespace slam {

//=============================================================================
// PLY Format Options
//=============================================================================

enum class PlyFormat {
    ASCII,              // Human-readable, larger file size
    BINARY_LITTLE_ENDIAN,  // Compact, fast to read/write
    BINARY_BIG_ENDIAN
};

struct PlyExportOptions {
    PlyFormat format = PlyFormat::BINARY_LITTLE_ENDIAN;
    bool include_intensity = true;
    bool include_rgb = false;       // Convert intensity to grayscale RGB
    bool include_normals = false;
    int precision = 6;              // Decimal places for ASCII format
};

//=============================================================================
// PLY Exporter
//=============================================================================

/**
 * @brief Export point cloud to PLY file
 * @param points Vector of LidarPoint
 * @param filename Output filename
 * @param options Export options
 * @return true on success
 */
inline bool exportToPly(const std::vector<LidarPoint>& points,
                        const std::string& filename,
                        const PlyExportOptions& options = PlyExportOptions()) {

    std::ofstream file;

    if (options.format == PlyFormat::ASCII) {
        file.open(filename);
    } else {
        file.open(filename, std::ios::binary);
    }

    if (!file.is_open()) {
        std::cerr << "[PLY Export] Failed to open file: " << filename << std::endl;
        return false;
    }

    // Write PLY header
    file << "ply\n";

    switch (options.format) {
        case PlyFormat::ASCII:
            file << "format ascii 1.0\n";
            break;
        case PlyFormat::BINARY_LITTLE_ENDIAN:
            file << "format binary_little_endian 1.0\n";
            break;
        case PlyFormat::BINARY_BIG_ENDIAN:
            file << "format binary_big_endian 1.0\n";
            break;
    }

    file << "comment Generated by SLAM Stack\n";
    file << "comment Intensity values preserved from LiDAR reflectivity\n";
    file << "element vertex " << points.size() << "\n";
    file << "property float x\n";
    file << "property float y\n";
    file << "property float z\n";

    if (options.include_intensity) {
        file << "property float intensity\n";
    }

    if (options.include_rgb) {
        file << "property uchar red\n";
        file << "property uchar green\n";
        file << "property uchar blue\n";
    }

    if (options.include_normals) {
        file << "property float nx\n";
        file << "property float ny\n";
        file << "property float nz\n";
    }

    file << "end_header\n";

    // Write point data
    if (options.format == PlyFormat::ASCII) {
        file << std::fixed << std::setprecision(options.precision);

        for (const auto& pt : points) {
            file << pt.x << " " << pt.y << " " << pt.z;

            if (options.include_intensity) {
                file << " " << pt.intensity;
            }

            if (options.include_rgb) {
                // Convert intensity to grayscale (0-255)
                uint8_t gray = static_cast<uint8_t>(std::min(255.0f, std::max(0.0f, pt.intensity)));
                file << " " << static_cast<int>(gray)
                     << " " << static_cast<int>(gray)
                     << " " << static_cast<int>(gray);
            }

            if (options.include_normals) {
                file << " 0 0 1";  // Default normal (up)
            }

            file << "\n";
        }
    } else {
        // Binary format
        for (const auto& pt : points) {
            file.write(reinterpret_cast<const char*>(&pt.x), sizeof(float));
            file.write(reinterpret_cast<const char*>(&pt.y), sizeof(float));
            file.write(reinterpret_cast<const char*>(&pt.z), sizeof(float));

            if (options.include_intensity) {
                file.write(reinterpret_cast<const char*>(&pt.intensity), sizeof(float));
            }

            if (options.include_rgb) {
                uint8_t gray = static_cast<uint8_t>(std::min(255.0f, std::max(0.0f, pt.intensity)));
                file.write(reinterpret_cast<const char*>(&gray), 1);
                file.write(reinterpret_cast<const char*>(&gray), 1);
                file.write(reinterpret_cast<const char*>(&gray), 1);
            }

            if (options.include_normals) {
                float nx = 0.0f, ny = 0.0f, nz = 1.0f;
                file.write(reinterpret_cast<const char*>(&nx), sizeof(float));
                file.write(reinterpret_cast<const char*>(&ny), sizeof(float));
                file.write(reinterpret_cast<const char*>(&nz), sizeof(float));
            }
        }
    }

    file.close();

    std::cout << "[PLY Export] Saved " << points.size() << " points to: " << filename << std::endl;
    return true;
}

/**
 * @brief Export PointCloud to PLY file
 */
inline bool exportToPly(const PointCloud& cloud,
                        const std::string& filename,
                        const PlyExportOptions& options = PlyExportOptions()) {
    return exportToPly(cloud.points, filename, options);
}

//=============================================================================
// World Point (for map export)
//=============================================================================

/**
 * @brief Point in world frame with intensity
 */
struct WorldPoint {
    float x, y, z;
    float intensity;

    WorldPoint() : x(0), y(0), z(0), intensity(0) {}
    WorldPoint(float x_, float y_, float z_, float i_ = 0)
        : x(x_), y(y_), z(z_), intensity(i_) {}

    WorldPoint(const V3F& p, float i = 0)
        : x(p.x()), y(p.y()), z(p.z()), intensity(i) {}

    WorldPoint(const V3D& p, float i = 0)
        : x(static_cast<float>(p.x())),
          y(static_cast<float>(p.y())),
          z(static_cast<float>(p.z())),
          intensity(i) {}

    V3F toEigen() const { return V3F(x, y, z); }
    V3D toEigenDouble() const { return V3D(x, y, z); }
};

/**
 * @brief Export world points to PLY
 */
inline bool exportToPly(const std::vector<WorldPoint>& points,
                        const std::string& filename,
                        const PlyExportOptions& options = PlyExportOptions()) {

    std::ofstream file;

    if (options.format == PlyFormat::ASCII) {
        file.open(filename);
    } else {
        file.open(filename, std::ios::binary);
    }

    if (!file.is_open()) {
        std::cerr << "[PLY Export] Failed to open file: " << filename << std::endl;
        return false;
    }

    // Write header
    file << "ply\n";

    switch (options.format) {
        case PlyFormat::ASCII:
            file << "format ascii 1.0\n";
            break;
        case PlyFormat::BINARY_LITTLE_ENDIAN:
            file << "format binary_little_endian 1.0\n";
            break;
        case PlyFormat::BINARY_BIG_ENDIAN:
            file << "format binary_big_endian 1.0\n";
            break;
    }

    file << "comment Generated by SLAM Stack\n";
    file << "element vertex " << points.size() << "\n";
    file << "property float x\n";
    file << "property float y\n";
    file << "property float z\n";

    if (options.include_intensity) {
        file << "property float intensity\n";
    }

    if (options.include_rgb) {
        file << "property uchar red\n";
        file << "property uchar green\n";
        file << "property uchar blue\n";
    }

    file << "end_header\n";

    // Write data
    if (options.format == PlyFormat::ASCII) {
        file << std::fixed << std::setprecision(options.precision);

        for (const auto& pt : points) {
            file << pt.x << " " << pt.y << " " << pt.z;

            if (options.include_intensity) {
                file << " " << pt.intensity;
            }

            if (options.include_rgb) {
                uint8_t gray = static_cast<uint8_t>(std::min(255.0f, std::max(0.0f, pt.intensity)));
                file << " " << static_cast<int>(gray)
                     << " " << static_cast<int>(gray)
                     << " " << static_cast<int>(gray);
            }

            file << "\n";
        }
    } else {
        for (const auto& pt : points) {
            file.write(reinterpret_cast<const char*>(&pt.x), sizeof(float));
            file.write(reinterpret_cast<const char*>(&pt.y), sizeof(float));
            file.write(reinterpret_cast<const char*>(&pt.z), sizeof(float));

            if (options.include_intensity) {
                file.write(reinterpret_cast<const char*>(&pt.intensity), sizeof(float));
            }

            if (options.include_rgb) {
                uint8_t gray = static_cast<uint8_t>(std::min(255.0f, std::max(0.0f, pt.intensity)));
                file.write(reinterpret_cast<const char*>(&gray), 1);
                file.write(reinterpret_cast<const char*>(&gray), 1);
                file.write(reinterpret_cast<const char*>(&gray), 1);
            }
        }
    }

    file.close();

    std::cout << "[PLY Export] Saved " << points.size() << " points to: " << filename << std::endl;
    return true;
}

//=============================================================================
// Trajectory Export
//=============================================================================

/**
 * @brief Export trajectory as PLY (line strip)
 * @param poses Vector of 4x4 pose matrices
 * @param filename Output filename
 */
inline bool exportTrajectoryToPly(const std::vector<M4D>& poses,
                                   const std::string& filename) {

    if (poses.empty()) return false;

    std::ofstream file(filename);
    if (!file.is_open()) return false;

    // Write header
    file << "ply\n";
    file << "format ascii 1.0\n";
    file << "comment Trajectory from SLAM Stack\n";
    file << "element vertex " << poses.size() << "\n";
    file << "property float x\n";
    file << "property float y\n";
    file << "property float z\n";
    file << "property uchar red\n";
    file << "property uchar green\n";
    file << "property uchar blue\n";
    file << "element edge " << (poses.size() - 1) << "\n";
    file << "property int vertex1\n";
    file << "property int vertex2\n";
    file << "end_header\n";

    // Write vertices
    file << std::fixed << std::setprecision(6);
    for (size_t i = 0; i < poses.size(); i++) {
        V3D pos = poses[i].block<3, 1>(0, 3);
        // Color gradient from green (start) to red (end)
        int r = static_cast<int>(255.0 * i / poses.size());
        int g = static_cast<int>(255.0 * (1.0 - static_cast<double>(i) / poses.size()));
        file << pos.x() << " " << pos.y() << " " << pos.z()
             << " " << r << " " << g << " 0\n";
    }

    // Write edges
    for (size_t i = 0; i < poses.size() - 1; i++) {
        file << i << " " << (i + 1) << "\n";
    }

    file.close();
    return true;
}

} // namespace slam

#endif // SLAM_PLY_EXPORT_HPP
